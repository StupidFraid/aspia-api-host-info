//
// Aspia Project
// Copyright (C) 2016-2025 Dmitry Chapyshev <dmitry@aspia.ru>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.1
// source: router_relay.proto

package router_relay

import (
	router "aspia_rest_api/proto/router"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RelayKeyPool struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PeerHost      string                 `protobuf:"bytes,1,opt,name=peer_host,json=peerHost,proto3" json:"peer_host,omitempty"`
	PeerPort      uint32                 `protobuf:"varint,2,opt,name=peer_port,json=peerPort,proto3" json:"peer_port,omitempty"`
	Key           []*router.RelayKey     `protobuf:"bytes,3,rep,name=key,proto3" json:"key,omitempty"` // A pool of one time keys.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayKeyPool) Reset() {
	*x = RelayKeyPool{}
	mi := &file_router_relay_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayKeyPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayKeyPool) ProtoMessage() {}

func (x *RelayKeyPool) ProtoReflect() protoreflect.Message {
	mi := &file_router_relay_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayKeyPool.ProtoReflect.Descriptor instead.
func (*RelayKeyPool) Descriptor() ([]byte, []int) {
	return file_router_relay_proto_rawDescGZIP(), []int{0}
}

func (x *RelayKeyPool) GetPeerHost() string {
	if x != nil {
		return x.PeerHost
	}
	return ""
}

func (x *RelayKeyPool) GetPeerPort() uint32 {
	if x != nil {
		return x.PeerPort
	}
	return 0
}

func (x *RelayKeyPool) GetKey() []*router.RelayKey {
	if x != nil {
		return x.Key
	}
	return nil
}

type RelayKeyUsed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyId         uint32                 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayKeyUsed) Reset() {
	*x = RelayKeyUsed{}
	mi := &file_router_relay_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayKeyUsed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayKeyUsed) ProtoMessage() {}

func (x *RelayKeyUsed) ProtoReflect() protoreflect.Message {
	mi := &file_router_relay_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayKeyUsed.ProtoReflect.Descriptor instead.
func (*RelayKeyUsed) Descriptor() ([]byte, []int) {
	return file_router_relay_proto_rawDescGZIP(), []int{1}
}

func (x *RelayKeyUsed) GetKeyId() uint32 {
	if x != nil {
		return x.KeyId
	}
	return 0
}

// Sent from relay to router.
type RelayStat struct {
	state          protoimpl.MessageState   `protogen:"open.v1"`
	PeerConnection []*router.PeerConnection `protobuf:"bytes,1,rep,name=peer_connection,json=peerConnection,proto3" json:"peer_connection,omitempty"`
	Uptime         int64                    `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RelayStat) Reset() {
	*x = RelayStat{}
	mi := &file_router_relay_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayStat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayStat) ProtoMessage() {}

func (x *RelayStat) ProtoReflect() protoreflect.Message {
	mi := &file_router_relay_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayStat.ProtoReflect.Descriptor instead.
func (*RelayStat) Descriptor() ([]byte, []int) {
	return file_router_relay_proto_rawDescGZIP(), []int{2}
}

func (x *RelayStat) GetPeerConnection() []*router.PeerConnection {
	if x != nil {
		return x.PeerConnection
	}
	return nil
}

func (x *RelayStat) GetUptime() int64 {
	if x != nil {
		return x.Uptime
	}
	return 0
}

// Sent from relay to router.
type RelayToRouter struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyPool       *RelayKeyPool          `protobuf:"bytes,1,opt,name=key_pool,json=keyPool,proto3" json:"key_pool,omitempty"`
	RelayStat     *RelayStat             `protobuf:"bytes,2,opt,name=relay_stat,json=relayStat,proto3" json:"relay_stat,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayToRouter) Reset() {
	*x = RelayToRouter{}
	mi := &file_router_relay_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayToRouter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayToRouter) ProtoMessage() {}

func (x *RelayToRouter) ProtoReflect() protoreflect.Message {
	mi := &file_router_relay_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayToRouter.ProtoReflect.Descriptor instead.
func (*RelayToRouter) Descriptor() ([]byte, []int) {
	return file_router_relay_proto_rawDescGZIP(), []int{3}
}

func (x *RelayToRouter) GetKeyPool() *RelayKeyPool {
	if x != nil {
		return x.KeyPool
	}
	return nil
}

func (x *RelayToRouter) GetRelayStat() *RelayStat {
	if x != nil {
		return x.RelayStat
	}
	return nil
}

// Sent from router to relay.
type RouterToRelay struct {
	state                 protoimpl.MessageState        `protogen:"open.v1"`
	KeyUsed               *RelayKeyUsed                 `protobuf:"bytes,1,opt,name=key_used,json=keyUsed,proto3" json:"key_used,omitempty"`
	PeerConnectionRequest *router.PeerConnectionRequest `protobuf:"bytes,2,opt,name=peer_connection_request,json=peerConnectionRequest,proto3" json:"peer_connection_request,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *RouterToRelay) Reset() {
	*x = RouterToRelay{}
	mi := &file_router_relay_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouterToRelay) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouterToRelay) ProtoMessage() {}

func (x *RouterToRelay) ProtoReflect() protoreflect.Message {
	mi := &file_router_relay_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouterToRelay.ProtoReflect.Descriptor instead.
func (*RouterToRelay) Descriptor() ([]byte, []int) {
	return file_router_relay_proto_rawDescGZIP(), []int{4}
}

func (x *RouterToRelay) GetKeyUsed() *RelayKeyUsed {
	if x != nil {
		return x.KeyUsed
	}
	return nil
}

func (x *RouterToRelay) GetPeerConnectionRequest() *router.PeerConnectionRequest {
	if x != nil {
		return x.PeerConnectionRequest
	}
	return nil
}

var File_router_relay_proto protoreflect.FileDescriptor

const file_router_relay_proto_rawDesc = "" +
	"\n" +
	"\x12router_relay.proto\x12\fproto.router\x1a\frouter.proto\"r\n" +
	"\fRelayKeyPool\x12\x1b\n" +
	"\tpeer_host\x18\x01 \x01(\tR\bpeerHost\x12\x1b\n" +
	"\tpeer_port\x18\x02 \x01(\rR\bpeerPort\x12(\n" +
	"\x03key\x18\x03 \x03(\v2\x16.proto.router.RelayKeyR\x03key\"%\n" +
	"\fRelayKeyUsed\x12\x15\n" +
	"\x06key_id\x18\x01 \x01(\rR\x05keyId\"j\n" +
	"\tRelayStat\x12E\n" +
	"\x0fpeer_connection\x18\x01 \x03(\v2\x1c.proto.router.PeerConnectionR\x0epeerConnection\x12\x16\n" +
	"\x06uptime\x18\x02 \x01(\x03R\x06uptime\"~\n" +
	"\rRelayToRouter\x125\n" +
	"\bkey_pool\x18\x01 \x01(\v2\x1a.proto.router.RelayKeyPoolR\akeyPool\x126\n" +
	"\n" +
	"relay_stat\x18\x02 \x01(\v2\x17.proto.router.RelayStatR\trelayStat\"\xa3\x01\n" +
	"\rRouterToRelay\x125\n" +
	"\bkey_used\x18\x01 \x01(\v2\x1a.proto.router.RelayKeyUsedR\akeyUsed\x12[\n" +
	"\x17peer_connection_request\x18\x02 \x01(\v2#.proto.router.PeerConnectionRequestR\x15peerConnectionRequestB%H\x03Z!aspia_rest_api/proto/router_relayb\x06proto3"

var (
	file_router_relay_proto_rawDescOnce sync.Once
	file_router_relay_proto_rawDescData []byte
)

func file_router_relay_proto_rawDescGZIP() []byte {
	file_router_relay_proto_rawDescOnce.Do(func() {
		file_router_relay_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_router_relay_proto_rawDesc), len(file_router_relay_proto_rawDesc)))
	})
	return file_router_relay_proto_rawDescData
}

var file_router_relay_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_router_relay_proto_goTypes = []any{
	(*RelayKeyPool)(nil),                 // 0: proto.router.RelayKeyPool
	(*RelayKeyUsed)(nil),                 // 1: proto.router.RelayKeyUsed
	(*RelayStat)(nil),                    // 2: proto.router.RelayStat
	(*RelayToRouter)(nil),                // 3: proto.router.RelayToRouter
	(*RouterToRelay)(nil),                // 4: proto.router.RouterToRelay
	(*router.RelayKey)(nil),              // 5: proto.router.RelayKey
	(*router.PeerConnection)(nil),        // 6: proto.router.PeerConnection
	(*router.PeerConnectionRequest)(nil), // 7: proto.router.PeerConnectionRequest
}
var file_router_relay_proto_depIdxs = []int32{
	5, // 0: proto.router.RelayKeyPool.key:type_name -> proto.router.RelayKey
	6, // 1: proto.router.RelayStat.peer_connection:type_name -> proto.router.PeerConnection
	0, // 2: proto.router.RelayToRouter.key_pool:type_name -> proto.router.RelayKeyPool
	2, // 3: proto.router.RelayToRouter.relay_stat:type_name -> proto.router.RelayStat
	1, // 4: proto.router.RouterToRelay.key_used:type_name -> proto.router.RelayKeyUsed
	7, // 5: proto.router.RouterToRelay.peer_connection_request:type_name -> proto.router.PeerConnectionRequest
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_router_relay_proto_init() }
func file_router_relay_proto_init() {
	if File_router_relay_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_router_relay_proto_rawDesc), len(file_router_relay_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_router_relay_proto_goTypes,
		DependencyIndexes: file_router_relay_proto_depIdxs,
		MessageInfos:      file_router_relay_proto_msgTypes,
	}.Build()
	File_router_relay_proto = out.File
	file_router_relay_proto_goTypes = nil
	file_router_relay_proto_depIdxs = nil
}
